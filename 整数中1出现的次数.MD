##题目描述
<font face="微软雅黑" size=4>
输入一个整数n，求1~n这n个整数的十进制表示中1出现的次数。例如，输入12,1~12这些整数中包含1的数字有1、10、11和12,1一共出现了5次。
</font>
##方法一(直观方法，不考虑时间效率)
<font face="微软雅黑" size=4>
思路如下：</br>
累加1~n中每个整数1出现的次数。可以通过对10取余数判断整数的个位数字是不是1。
如果这个数字大于10，则除以10之后再判断个位数字是不是1.</br>
时间复杂度O(nlogn)
</font>

    class Solution {
    public:
        int NumberOf1Between1AndN_Solution(int n)
        {
            int number = 0;
            //将每个位出现的1进行相加
            for(int i=1; i<=n; i++)
            {
                number += NumberOfOne(i);
            }
            return number;
        }
    private:
        int NumberOfOne(int n)
        {
            int number = 0;
            //分别求每个位中1出现的次数
            while(n)
            {
                if(n%10 == 1)
                {
                    ++number;
                }
                n /= 10;
            }
            return number;
        }
    };

##方法二
思路：时间复杂度O(logn)
https://www.cnblogs.com/xuanxufeng/p/6854105.html
我们从一个5位的数字讲起，先考虑其百位为1的情况。分3种情况讨论：

百位数字>=2  example: 31256  当其百位为>=时，有以下这些情况满足(为方便起见，计312为a，56为b)：
   100 ~   199
  1100 ~  1199
     .....
 31100 ~ 31199

 余下的都不满足！

因此，百位>=2的5位数字，其百位为1的情况有（a/10+1）*100个数字   
（a/10+1）=>对应于 0 ~ 31，且每一个数字，对应范围是100个数（末尾0-99）

百位数字 ==1 example: 31156 当其百位为1时，有以下这些情况满足：

    100 ~   199

   1100 ~  1199

     ......

  30100 ~ 30199

  31100 ~ 31156

因此，百位为1的5位数字，共有（a/10）*100+(b+1)

百位数字 ==0 example: 31056 当其百位为0时，有以下这些情况满足：

     100 ~   199

    1100 ~  1199

   30100 ~ 30199

  其余都不满足

因此，百位数为0的5位数字，共有(a/10)*100个数字满足要求

我们可以进一步统一以下表达方式，即当百位>=2或=0时，有[(a+8)/10]*100，当百位=1时，有[(a+8)/10]*100+(b+1)。用代码表示就是： [(a+8)/10]*100+(a%10==1)?(b+1):0；

为什么要加8呢？因为只有大于2的时候才会产生进位等价于（a/10+1），当等于0和1时就等价于(a/10)。另外，等于1时要单独加上(b+1)，这里我们用a对10取余是否等于1的方式判断该百位是否为1。

Question：有缺陷或逻辑错误吗？
有人可能会有疑惑，比如11100，这个数在考虑百位为1的时候算作了一次，在考虑千位的时候也算了一次，在考虑万位为1的时候又算了一次，一共计了3次，这不是明显重复吗？

我的回答是，不重复！

分析：题目中要我们统计出现的1的个数，那么我们可以看到11100一共是3个1,如果剔除了重复的情况只考虑一次才会是问题。换言之，在计算从1到n整数中1的出现次数时，我们把10位出现1的情况个数加上百位出现1的情况个数一直加到最高位是1的情况的个数，这里面一个数可能被统计过多次；11100百位出现1，千位和万位都为1，那么被重复统计了3次。

for (long m = 1; m <= n; m *= 10) 在这里的作用是，从个位开始考虑，再到十位，百位，千位，一直到超出这个数！为什么m要用long型呢？因为n可能没有超过整型的表达范围（int刚好可以表示n），而10*m恰恰有可能刚刚超过！ones += (n/m + 8) / 10 * m + (n/m % 10 == 1 ? n%m + 1 : 0); 这里ones用于表示1的个数，当m=100时，n/m其实代表的是a，而n%m代表的是b,此时考虑的是百位为1的情况；当m=1000，自然考虑的就是千位等于1的情况了~ 至于为什么加8，那个三目运算符是干嘛子用的上面都已经讲过了。

    class Solution {
    public:
    int NumberOf1Between1AndN_Solution(int n)
    {
        int ones = 0;
        for(long i=1; i<=n; i *= 10)
        {
            ones += (n/i+8) / 10*i + (n/i % 10 == 1 ? n%i + 1 : 0);
        }
        return ones;
        }
    };